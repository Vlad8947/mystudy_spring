КОНТЕКСТ ПОСТОЯНСТВА

Результат операции никак не отразится на базе данных, пока не будет произведена фиксация транзакции. Процесс состоит из следующих этапов:
- открытие транзакции;
- сохранение объекта в контексте постоянства с помощью метода persist;
- сохранение объекта в базе данных после фиксации транзакции.

EntityManager содержит и другие методы, предназначенные для работы с сущностями:
- detach(Object obj) – удаляет сущность obj из контекста постоянства (но не из БД), и объект перестает находится под управлением Hibernate;
- refresh(Object obj) – синхронизирует сущность obj c БД. Ее поля будут иметь те значения, которые находились в столбцах строки БД на момент применения данного метода.

-----------
СПОСОБЫ ПОДГРУЗКИ ВНУТРЕННИХ СУЩНОСТЕЙ (Country)

Есть две стратегии выборки, которые задаются в атрибуте fetch аннотаций @OneToOne, @OneToMany, @ManyToOne, @ManyToMany:
- LAZY – «ленивая» выборка, при которой поля, являющиеся другими сущностями, не вытягиваются из базы данных вместе с основной сущностью, а запрашиваются отдельно (дополнительным запросом в БД), только при вызове геттера данного поля;
- EAGER – ранняя выборка, при которой поля, являющиеся сущностями, вытягиваются из базы вместе с основной сущностью с помощью одного запроса к БД.

Атрибут fetch аннотаций связи может иметь следующие значения:
- FetchType.LAZY – для ленивой выборки;
- FetchType.EAGER – для ранней выборки.

По умолчания каждая из связей использует стратегии следующим образом:
@OneToOne - EAGER
@ManyToOne - EAGER
@OneToMany - LAZY
@ManyToMany - LAZY

Задавать стратегию выборки можно и для простых атрибутов. Это можно осуществить с помощью аннотации @Basic.

---------------
КАСКАДНЫЕ ОПЕРАЦИИ К ВНУТРЕННИМ СУЩНОСТЯМ (Country)

Помимо стратегии выборки в атрибутах аннотаций связи можно указывать параметры каскадирования операций. Фактически, это означает, что при удалении сущности A из соответствующей таблицы в БД удаляется и ее дочерняя сущность B.

В коде каскадирование задается в атрибуте cascade аннотаций связи. Данный атрибут может принимать следующие значения перечисления CascadeType пакета javax.persistence.CascadeType:
CascadeType.ALL – каскадирование будет применяться ко всем операциям;
CascadeType.REMOVE – только к методу удаления;
CascadeType.PERSIST – только к методу сохранения;
CascadeType.MERGE – к методу обновления;
CascadeType.REFRESH – к методу синхронизации с БД;
CascadeType.DETACH – каскадирование применяется к методу удаления сущности из контекста постоянства (но не из БД).

-----------
ДИНАМИЧЕСКИЕ ЗАПРОСЫ

Изучим механизм, с помощью которого осуществляются запросы. Весь необходимый функционал содержится в методах класса EntityManager.
Рассмотрим основные методы :
createQuery(String jpqlString) – метод, принимающий  строку JPQL-запроса и  возвращающий объект класса Query;
createNamedQuery(String name) – метод для именованных запросов, принимающий их названия и возвращающий объекты класса Query;
createNativeQuery(String sqlString) – метод для запросов с использованием SQL, возвращает объект класса Query и других.
Эти методы имеют свои перегруженные аналоги, принимающие дополнительный параметр типа Class или Class<T>, которые помогают избежать лишних преобразований типов.
Но стоит отметить, что все вышеперечисленные методы не обеспечивают выполнение запроса как такового – для этого необходимо использовать следующие методы получения результата:
getSingleResult() – для получения одиночного объекта в качестве конечного результата запроса;
getResultList() – для получения коллекции объектов конечного результата запроса и др.

----------------
ИМЕНОВАНЫЕ ЗАПРОСЫ (Country, CountryDAOImpl.findAll())

Именованные запросы более производительны, чем динамические. Это связано с тем, что преобразование JPQL-запроса в SQL происходит сразу после запуска приложения. Чтобы выполнить именованный запрос, в классе, к которому он будет осуществляться, необходимо объявить аннотацию
@NamedQuery, содержащую следующие атрибуты:
name – название именованного запроса;
query – JPQL-строка запроса.
Можно объявлять несколько именованных запросов с помощью множественной аннотации
@NamedQueries.

----------------
DAO

DAO (Data Access Object) – это уровень доступа к данным. Весь функционал DAO основывается на классе EntityManager. Чтобы создать DAO-уровень для сущности, необходимо выполнить следующие действия:
- создать отдельный пакет для классов уровня доступа к данным, например net.zt.funcode.dao;
- создать интерфейс доступа к сущности, например ArticleDAO;
- в интерфейсе объявить методы, исходя из набора требующихся операций над сущностью;
- создать класс, имплементирующий данный интерфейс, и реализовать в нем методы интерфейса, используя EntityManager для
    обеспечения  функционала;

@Repository. Это уточняющая аннотация по отношению к @Component. Указывает на то, что данный компонент необходим для
доступа к данным. Фактически, @Repository является одним из видов аннотации @Component.

@PersistenceContext, в отличии от @Autowired, обладает широким набором атрибутов, которые необходимы для точного
указания настроек контекста постоянства.

---------------
Spring Data JPA (CountryRepository). Требуется зависимость "spring-data-jpa"

Spring Data JPA является абстракцией над Hibernate, который реализует спецификацию JPA.
Используя Spring Data JPA, мы оперируем репозиториями, а не DAO.

Если функционала методов JpaRepository недостаточно, а описать запрос через название метода проблематично, то можно
воспользоваться JPQL (CountryRepository.findArticleByCountry())

Чтобы использовать этот класс, необходимо произвести внедрение с помощью @Autowired по данному интерфейсу.

----------------
СЕРВИС-УРОВЕНЬ (CountryServiceImpl)

В сервис-уровень помещена необходимая бизнес-логика, которая оперирует данными, получаемыми из уровня доступа к данным и
    веб-уровня. В методах сервис-уровня происходит работа с транзакциями.

Управление транзакциями бывает двух видов:
управление приложением – явное открытие и фиксация транзакций разработчиком;
управление контейнером – управление транзакциями делегируется контейнеру, в котором выполняется приложение.

@Transactional - Чтобы указать контейнеру, что в методе необходимо открыть транзакцию и зафиксировать ее по окончании
выполнения метода. Если транзакция подразумевает только чтение из БД, то можно воспользоваться атрибутом readOnly и
указать значение true.

----------------
AppConfig

@EnableJpaRepositories – обеспечивает возможность использования Spring Data JPA. В качестве параметра указывается пакет,
в котором будут находиться классы-репозитории;

@EnableTransactionManagement – указывает Spring на необходимость в управлении транзакциями;

Бин transactionManager – менеджер транзакций, который работает «поверх» менеджера сущностей.

